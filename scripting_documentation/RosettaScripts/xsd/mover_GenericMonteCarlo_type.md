<!-- THIS IS AN AUTOGENERATED FILE: Don't edit it directly, instead change the schema definition in the code itself. -->

_Autogenerated Tag Syntax Documentation:_

---
Allows sampling structures by MonteCarlo with a mover. The score evaluation of pose during MC are done by Filters that can do report_sm(), not only ScoreFunctions

```xml
<GenericMonteCarlo name="(&string;)" trials="(10 &non_negative_integer;)"
        temperature="(0.0 &real;)" task_scaling="(5 &non_negative_integer;)"
        adaptive_movers="(false &bool;)"
        adaptation_period="(&non_negative_integer;)" mover_name="(&string;)"
        filter_name="(true_filter &string;)" adaptive="(true &bool;)"
        sample_type="(low &string;)" scorefxn_name="(&string;)"
        task_operations="(&task_operation_comma_separated_list;)"
        packer_palette="(&named_packer_palette;)"
        stopping_condition="(false_filter &string;)" drift="(true &bool;)"
        preapply="(true &bool;)" recover_low="(true &bool;)"
        bolz_rank="(false &bool;)" saved_accept_file_name="(&string;)"
        max_accepted_trials="(&non_negative_integer;)"
        saved_trial_number_file="(&string;)" mover_tag="(&string;)"
        reset_baselines="(true &bool;)" progress_file="(&string;)" >
    <Filters >
        <AND filter_name="(&string;)" temperature="(1 &real;)" adaptive="(true &bool;)"
                sample_type="(low &string;)" rank="(false &bool;)" />
    </Filters>
</GenericMonteCarlo>
```

-   **trials**: The number of trials in a GenericMonteCarlo run. Will be automatically calculated when a task is included. See task_scaling for more information.
-   **temperature**: Temperature value which affects the acceptance of new solutions according to the MC criterion
-   **task_scaling**: If a task is included, the number of designable residues will be calculated and the number of trials will be automatically set as task_scaling * (number designable residues). For example, if there are 10 designable residues and task_scaling is 5 (the default) the number of trials will be 50.
-   **adaptive_movers**: If the mover you call or a submover of that mover is of type ParsedProtocol with mode single-random, then GenericMonteCarlo can 'learn' the best sampling strategy by adapting the apply probabilities of individual movers within that ParsedProtocol. For each adaptation period (say 20 mover applies) the number of accepts of each submover is recorded (with pseudocounts of 1 for each mover) and during the next adaptation period the apply probabilities of the submovers in the ParsedProtocol are adjusted according in proportion to the acceptance probabilities of the previous stage. Due to the pseudocounts, all movers have at least some chance of being called.
-   **adaptation_period**: goes together with adaptive_movers, defined above. Defaults to max( max_trials/10, 10 ) but can be set to any integer.
-   **mover_name**: Mover to be used for sampling.
-   **filter_name**: Single filter case. See Filters subcategory for applying multiple filters.
-   **adaptive**: If the mover you call or a submover of that mover is of type ParsedProtocol with mode single-random, then GenericMonteCarlo can 'learn' the best sampling strategy by adapting the apply probabilities of individual movers within that ParsedProtocol. For each adaptation period (say 20 mover applies) the number of 'accepts of each submover is recorded (with pseudocounts of 1 for each mover) and during the next adaptation period the apply probabilities of the submovers in the ParsedProtocol are adjusted according in proportion to the acceptance probabilities of the previous stage. Due to the pseudocounts, all movers have at least some chance of being called.
-   **sample_type**: low - MC samples by minimizing the structure score (REU: the more negative the better); high - MC samples by maximizing the structure score
-   **scorefxn_name**: As alternative to scoring by filters (See Filters subcategory), structures may be scored by a given scoring function.
-   **task_operations**: A comma-separated list of TaskOperations to use.
-   **packer_palette**: A previously-defined PackerPalette to use, which specifies the set of residue types with which to design (to be pruned with TaskOperations).
-   **stopping_condition**: stops before trials are done if a filter evaluates to true
-   **drift**: true - the state of the pose at the end of the previous iteration will be the starting state for the next iteration; false - the state of the pose at the start of each iteration will be reset to the state when the mover is first called ( Of course, this is not MC ).
-   **preapply**: true - Automatically accept the first application of the sub-mover, ignoring the Boltzmann criterion. false - apply Boltzmann accept/reject to all applications of the mover. Though defaulting to true for historical reasons, it is highly recommended to set this to false unless you know you need it to be true.
-   **recover_low**: true - at the end of application, the pose is set to the lowest (or highest if sample_type="high") scoring pose; false - the pose after apply completes is the last accepted pose
-   **bolz_rank**: For use with multiple filters. If no sub-filters are set with rank=1, the first filter is used for ranking. As a special case, if boltz_rank is set to true, the ranking score is a temperature-weighted sum of all filter values. (This value is equivalent to the effective value optimized by the MC protocol.) This boltz_rank score is computed by the equation SUM( multiplier * filter_value / filter_temperature ) over all filter values, where filter_value is the value returned by the filter and multiplier is 1 if the filter sample_type is low and -1 if the filter sample_type is high.
-   **saved_accept_file_name**: save the most recent accepted structure in a temporary PDB? This allows recovery by checkpointing. Note that different processes would need to work from different directories or somehow control the checkpointing file name, else confusion will reign.
-   **max_accepted_trials**: The maximum number of accepted trials. If not set max_accepted_trials=trials
-   **saved_trial_number_file**: Checkpointing file for the current trial number. Allows the mover to recover after failure.
-   **mover_tag**: this is used by the called movers to set a certain tag. If saved_accept_file_name_ is set, then at exit the tag coming from the chosen mover is written to disk as, {saved_accept_file_name}.mover_tag. To work, mover_tag_ must be exposed to the movers being called.
-   **reset_baselines**: If the filter is of type Sigmoid/Operator/CompoundStatement, look for all subfilters of type Sigmoid and reset their baseline to the pose's current filter evaluation at trial=1. Useful in cases where you want to set the thresholds relative to the pose's evaluation at the start of the MC trajectory.
-   **progress_file**: If specified opens a file in which each trial's outcome is reported (trial number, accept/reject, filter value, and pose sequence). Useful to monitor progress in MC


Subtag **Filters**:   Multiple filters can be defined for an MC mover. These filters are then applied sequentially in the order listed and only if the pose passes the Metropolis criterion for all filters is it accepted. This allows the extension of MC to a multicriterion framework where more than one criterion is optimized, say the total score and the binding energy. See demos/rosetta_scripts/experimental/computational_affinity_maturation_strategy2 for an example. It's recommended to list the computationally expensive filters last, as later filters will only be calculated if the earlier filters all pass.



Subtag **AND**:   

-   **filter_name**: name of the filter declaration
-   **temperature**: Filter specific temperature
-   **adaptive**: Incorporate this filter when using adaptive scores.
-   **sample_type**: high - the filter evalutas good structures with positive scores; low - the filter evaulates good structures with negative scores
-   **rank**: Give this filter a rank of 1. Can only be applied for one filter. A filter with rank 1 will score the structure solitarily.

---
