<!-- THIS IS AN AUTOGENERATED FILE: Don't edit it directly, instead change the schema definition in the code itself. -->

_Autogenerated Tag Syntax Documentation:_

---
This is the Hybridize mover at the core of comparative modeling (RosettaCM).  Typically its XML is written by a script rather than manually.

```xml
<Hybridize name="(&string;)" stage1_increase_cycles="(1.0 &real;)"
        stage2_increase_cycles="(1.0 &real;)" stage2_temperature="(2.0 &real;)"
        stage2.5_increase_cycles="(1.0 &real;)" fa_cst_file="(&string;)"
        batch="(1 &non_negative_integer;)" jump_move="(false &bool;)"
        jump_move_repeat="(1 &non_negative_integer;)"
        keep_pose_constraint="(false &bool;)" cenrot="(false &bool;)"
        csts_from_frags="(&bool;)"
        max_contig_insertion="(&non_negative_integer;)"
        min_after_stage1="(&bool;)" fragprob_stage2="(&real;)"
        randfragprob_stage2="(&real;)"
        stage1_1_cycles="(&non_negative_integer;)"
        stage1_2_cycles="(&non_negative_integer;)"
        stage1_3_cycles="(&non_negative_integer;)"
        stage1_4_cycles="(&non_negative_integer;)" stage1_probability="(&real;)"
        add_hetatm="(&bool;)" hetatm_cst_weight="(&real;)"
        hetatm_to_protein_cst_weight="(&real;)" realign_domains="(&bool;)"
        realign_domains_stage2="(&bool;)" add_non_init_chunks="(&real;)"
        frag_1mer_insertion_weight="(&real;)"
        small_frag_insertion_weight="(&real;)"
        big_frag_insertion_weight="(&real;)" chunk_insertion_weight="(&real;)"
        frag_weight_aligned="(&real;)" auto_frag_insertion_weight="(&bool;)"
        max_registry_shift="(&non_negative_integer;)"
        repeats="(&non_negative_integer;)" disulf_file="(&string;)"
        no_global_frame="(&bool;)" linmin_only="(&bool;)"
        cartfrag_overlap="(&non_negative_integer;)"
        seqfrags_only="(&non_negative_integer;)"
        skip_long_min="(&non_negative_integer;)" stage1_scorefxn="(&string;)"
        stage2_scorefxn="(&string;)" stage2_min_scorefxn="(&string;)"
        stage2_pack_scorefxn="(&string;)" fa_scorefxn="(&string;)"
        domain_pcut="(0.18 &real;)" domain_hcut="(0.81 &real;)"
        domain_length="(38 &non_negative_integer;)"
        coord_cst_res="(&resnum_list_with_ranges;)" >
    <Fragments three_mers="(&string;)" small="(&string;)" nine_mers="(&string;)"
            big="(&string;)" />
    <Template pdb="(&string;)" cst_file="(AUTO &string;)" weight="(1.0 &real;)"
            symmdef="(&string;)" randomize="(&string;)" auto_align="(true &bool;)" />
    <Pairings file="(&string;)" sheets="(&non_negative_integer;)"
            random_sheets="(&non_negative_integer;)"
            filter_templates="(false &bool;)" />
    <DetailedControls start_res="(1 &non_negative_integer;)"
            stop_res="(&non_negative_integer;)" sample_template="(true &bool;)"
            sample_abinitio="(true &bool;)"
            task_operations="(&task_operation_comma_separated_list;)"
            packer_palette="(&named_packer_palette;)" />
</Hybridize>
```

-   **stage1_increase_cycles**: Increase/decrease sampling in stage 1
-   **stage2_increase_cycles**: Increase/decrease sampling in stage 2
-   **stage2_temperature**: kT for the Monte Carlo simulation
-   **stage2.5_increase_cycles**: Increase/decrease number of minimization steps following stage 2
-   **fa_cst_file**: constraints file for fullatom stage
-   **batch**: The number of centroid structures to generate per fullatom model. Setting this to 0 will only run centroid modeling.
-   **jump_move**: rigid body moves in stage 1
-   **jump_move_repeat**: cycles in stage 1 that handle rigid body moves
-   **keep_pose_constraint**: If set to true, keep constraints on the incoming pose (useful if constraints are generated in a mover prior to hybridize)
-   **cenrot**: centroid rotamer modeling; necessary for stage2_pack_scorefxn to be useful; probably requires command line option -corrections:score:cenrot
-   **csts_from_frags**: when set, derives dihedral constraints from input fragments; you need to set 'dihedral_constraint' weight in the stages you want to use this
-   **max_contig_insertion**: Limits the length of 'template recombination' moves. Useful when inputs are full-length (no gaps).
-   **min_after_stage1**: minimize after stage 1 (?)
-   **fragprob_stage2**: controls the ratio of fragment insertions versus template recombination moves, implicit default 0.3
-   **randfragprob_stage2**: controls the number of random fragfile insertions versus 'cutpoint' insertions, implicit default 0.5
-   **stage1_1_cycles**: set number of cycles for this stage
-   **stage1_2_cycles**: set number of cycles for this stage
-   **stage1_3_cycles**: set number of cycles for this stage
-   **stage1_4_cycles**: set number of cycles for this stage
-   **stage1_probability**: probability of doing 'fold tree hybridize' for stage one (with rigid body moves(?) instead of 'frag insertion in unaligned regions'
-   **add_hetatm**: If true, use ligands from input template files
-   **hetatm_cst_weight**: If add_hetatm is enabled, this will set the weight on automatically generated intra-ligand restraints.  Called hetatm_self_cst_weight in documentation.
-   **hetatm_to_protein_cst_weight**: If add_hetatm is enabled, this will set the weight on automatically generated ligand-protein restraints. Called hetatm_prot_cst_weight in documentation.
-   **realign_domains**: If unset, this will not align the input domains to each other before running the protocol. Unsetting this option requires that input domains be previously aligned to a common reference frame. This option may be useful to unset for building models into density (if all inputs are docking into density).
-   **realign_domains_stage2**: If set, realign domains in between the two centroid stages; default only aligns the initial models.
-   **add_non_init_chunks**: Normally, secondary structure chunks are used from the starting model to set the foldtree. This option will steal chunks from other templates as well (as long as they do not overlap with current chunks); the number is the expected number of chunks (poisson distribution). This option is recommended when starting from an extended chain.
-   **frag_1mer_insertion_weight**: For fine control of protocol behavior, control the relative weight of this move type.
-   **small_frag_insertion_weight**: For fine control of protocol behavior, control the relative weight of this move type.
-   **big_frag_insertion_weight**: For fine control of protocol behavior, control the relative weight of this move type.
-   **chunk_insertion_weight**: For fine control of protocol behavior, control the relative weight of this move type.
-   **frag_weight_aligned**: Allow fragment insertions in template regions. The default is 0; increasing this will lead to increased model diversity.
-   **auto_frag_insertion_weight**: automatically set fragment insertion weights
-   **max_registry_shift**: Add a random move that shifts the sequence during model-building
-   **repeats**: repeats for relax step
-   **disulf_file**: If specified, force the attached disulfide patterning
-   **no_global_frame**: only valid in Cartesian Hybridize; undocumented
-   **linmin_only**: only valid in Cartesian Hybridize; undocumented
-   **cartfrag_overlap**: only valid in Cartesian Hybridize; undocumented
-   **seqfrags_only**: only valid in Cartesian Hybridize; undocumented
-   **skip_long_min**: only valid in Cartesian Hybridize; skip a final minimization
-   **stage1_scorefxn**: Scorefunction for stage 1 (looked up from DataMap
-   **stage2_scorefxn**: Scorefunction for stage 2 (looked up from DataMap
-   **stage2_min_scorefxn**: Scorefunction for stage 2 minimization (looked up from DataMap
-   **stage2_pack_scorefxn**: Scorefunction for stage 2 'packing' (looked up from DataMap. Only valid if boolean cenrot is true.
-   **fa_scorefxn**: Scorefunction for fullatom stage (looked up from DataMap
-   **domain_pcut**: Used in DDomainParse. Aggressively undocumented.
-   **domain_hcut**: Used in DDomainParse. Aggressively undocumented.
-   **domain_length**: Used in DDomainParse.  Aggressively undocumented.
-   **coord_cst_res**: List of residue numbers to use


Subtag **Fragments**:   Instructions for fragments files.  Should occur exactly once.

-   **three_mers**: 3mers fragments file
-   **small**: comma separated vector of small (probably 3mer) fragments files
-   **nine_mers**: 9mers fragments file
-   **big**: comma separated vector of small (probably 3mer) fragments files

Subtag **Template**:   Instructions for templates. Must occur at least once, may occur as many times as you wish.

-   **pdb**: (REQUIRED) file path to pdb template
-   **cst_file**: file path to constraints file associated with this template
-   **weight**: Sampling frequency weight for this template
-   **symmdef**: symmdef file associated with this template (only if using symmetry)
-   **randomize**: comma-seprated list of chains to randomize - not documented
-   **auto_align**: frustratingly undocumented

Subtag **Pairings**:   Used with FoldTreeHybridize and poorly documented

-   **file**: (REQUIRED) path to pairings file
-   **sheets**: used with FoldTreeHybridize, undocumented sheets and random_sheets are mutually exclusive.
-   **random_sheets**: used with FoldTreeHybridize, undocumented sheets and random_sheets are mutually exclusive.
-   **filter_templates**: remove templates with incorrect pairings

Subtag **DetailedControls**:   Used to prevent regions from being sampled extensively (meaning, don't remodel regions where the model is already correct)

-   **start_res**: starting residue for a DetailedControl region
-   **stop_res**: ending residue for a DetailedControl region; defaults to the rest of the Pose
-   **sample_template**: if false, disallow template hybridization moves
-   **sample_abinitio**: if false, disallow fragment insertion moves
-   **task_operations**: A comma-separated list of TaskOperations to use.
-   **packer_palette**: A previously-defined PackerPalette to use, which specifies the set of residue types with which to design (to be pruned with TaskOperations).

---
