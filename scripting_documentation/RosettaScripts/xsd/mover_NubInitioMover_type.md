<!-- THIS IS AN AUTOGENERATED FILE: Don't edit it directly, instead change the schema definition in the code itself. -->

_Autogenerated Tag Syntax Documentation:_

---
The Nub Initio mover generates a low definition (centroid level) ab initio folding (with or withou constraints) around a foreing static piece of structure called Nub. Effectively, it grafts the Nub inside a template protein and then folds that protein around to better fit the inserted Nub. The region of the template that will be substituted (i.e. not kept) is the 'motif'. The pose that comes at apply time is considered the template. If the template pose is discontinued, this might produce unexpected and possibly fatal results. Finally a full atom pose is provided keeping the original residue types of the template. This pose should not be consider OK to terminate the run at that point; at least the template residues need to be redesigned.

```xml
<NubInitioMover name="(&string;)" use_cst="(1 &bool;)" ss="(&dssp_string;)"
        max_trials="(10 &integer;)" clear_motif_cst="(1 &bool;)"
        rmsd_threshold="(5.000000 &real;)" rmsd_include_motif="(0 &bool;)"
        rmsd_include_unconstrained="(1 &bool;)"
        binder_weight="(0.000000 &real;)" angle_weight="(0.000000 &real;)"
        dihedral_weight="(0.000000 &real;)" correction_weights="(1 &bool;)"
        repack_disulfides="(1 &bool;)" disulfides_bb="(0 &bool;)"
        disulfides_side="(0 &integer;)" filter_name="(true_filter &string;)"
        fragments_id="(&string;)" dump_centroid="(0 &bool;)"
        drop_unfolded_pose="(0 &bool;)" design="(0 &bool;)"
        residue_type="(&string;)" fullatom_scorefxn="(&string;)"
        filter_scorefxn="(&string;)" template_motif_selector="(&string;)" >
    <Nub pose_file="(&string;)" reference_name="(&string;)"
            residue_selector="(&string;)" binder_selector="(&string;)" >
        <Segment order="(&integer;)" n_term_flex="(0 &integer;)"
                c_term_flex="(0 &integer;)" editable="(&int_cslist;)" />
    </Nub>
</NubInitioMover>
```

-   **use_cst**: Use constraints to guide the folding (RECOMENDED). Basically this is the difference between running ClassicAbinitio or FoldConstraints. Be aware that the constraints MUST have been set into the Pose beforehand with a ConstraintGenerator.
-   **ss**: Force assign SSE to the template (otherwise use DSSP)
-   **max_trials**: Defines how many times we should try to fold the protein under a RMSD threshold with the template before giving up.
-   **clear_motif_cst**: This will clear any constraint that includes residues of the template's motif; i.e. the part of the template that will be substituted by the Nub. This option is relevant when the 3D configuration of the motif and the Nub differ greatly. Be aware that this change is applied to the pose, and, thus, these constraints will not be available in further Movers. (WARNING!) When the size of motif and Nub do not match, this should be kept as TRUE.
-   **rmsd_threshold**: Maximum allow difference between the obtained decoy and the original template.
-   **rmsd_include_motif**: Use all the residues of the template, including those of the motif, to calculate RMSD.(WARNING!) When the size of motif and Nub do not match, this should be kept as FALSE.
-   **rmsd_include_unconstrained**: Use all the residues of the template, including those that had no assigned constraint (this excludes SequenceComposition constraints). This is interesting if a segment of the template was left unsconstraint on purpose so that it would move for example, to avoid clashed with a binder. It would allow to set tighter RMSD filtering while leaving this particular region alone,
-   **binder_weight**: Weight for interchain scores to add to the AbInitio MonteCarlo's evaluator default score (0 - no weight).
-   **angle_weight**: Weight for angle constraints to add to the AbInitio MonteCarlo's evaluator default score (0 - no weight).
-   **dihedral_weight**: Weight for dihedral constraints to add to the AbInitio MonteCarlo's evaluator default score (0 - no weight).
-   **correction_weights**: When true (default), it will autodetect the presence of helix/sheet in the template and add scoring terms appropiately.
-   **repack_disulfides**: Force disulfide awarenes to guide ab initio.
-   **disulfides_bb**: Allow backbone movements to try to fix disulfides.
-   **disulfides_side**: Defines number of sequence neighbors around CYS residues allowed to pack/minimize in order to achieve the disulfide bridge.
-   **filter_name**: Name of an alternative filter to use instead of RMSD distance (applied at CENTROID level).
-   **fragments_id**: (REQUIRED) Fragments are necessary to perform the ab initio run. They need to be included/created with StructFragmentMover. The value set in the 'prefix' attribute of that Mover needs to be provided here again.
-   **dump_centroid**: Output centroid level structures in a outputname_CENTROID silent file.
-   **drop_unfolded_pose**: For testing and imaging. Stops the process just after creating the unfolded pose (still full atom)
-   **design**: If true, run design on the template residues
-   **residue_type**: Change all template residues to the specified residue name (name1)
-   **fullatom_scorefxn**: Full atom score for disulfide optimization and repacking, if needed. If not specified calls Rosetta's default full atom score.
-   **filter_scorefxn**: Score applied to the defined filter_name. Provide a CENTROID scoring function. If not specified calls Rosetta's default centroid atom score.
-   **template_motif_selector**: (REQUIRED) Selector specifying the residues from the template that will be substituted for the Nub; i.e. everything from the template thatwe WON'T KEEP. This region is dubed as the template's motif. The name of a previously declared residue selector or a logical expression of AND, NOT (!), OR, parentheses, and the names of previously declared residue selectors. Any capitalization of AND, NOT, and OR is accepted. An exclamation mark can be used instead of NOT. Boolean operators have their traditional priorities: NOT then AND then OR. For example, if selectors s1, s2, and s3 have been declared, you could write: 's1 or s2 and not s3' which would select a particular residue if that residue were selected by s1 or if it were selected by s2 but not by s3.


Subtag **Nub**:   Describes the static segment in the NubInitio protocol

-   **pose_file**: File containing the structure with the static segment to keep (Nub). This option will be ignored if a reference_pose loaded with SavePoseMover is provided.
-   **reference_name**: Reference pose containing the structure with the static segment to keep (Nub). This option will override the pose_file option.
-   **residue_selector**: (REQUIRED) Selector specifying residues that will be kept as the Nub structure. The number of segments this selector specifies has to be the same as the number of motifs that the template selector will specify in the NubInitio Mover, but the sizes do not have to be the same. The name of a previously declared residue selector or a logical expression of AND, NOT (!), OR, parentheses, and the names of previously declared residue selectors. Any capitalization of AND, NOT, and OR is accepted. An exclamation mark can be used instead of NOT. Boolean operators have their traditional priorities: NOT then AND then OR. For example, if selectors s1, s2, and s3 have been declared, you could write: 's1 or s2 and not s3' which would select a particular residue if that residue were selected by s1 or if it were selected by s2 but not by s3.
-   **binder_selector**: If provided, it selects a binder to be placed together with the region of interest in the Nub. The binder(s) will be static during the Ab initio process. The name of a previously declared residue selector or a logical expression of AND, NOT (!), OR, parentheses, and the names of previously declared residue selectors. Any capitalization of AND, NOT, and OR is accepted. An exclamation mark can be used instead of NOT. Boolean operators have their traditional priorities: NOT then AND then OR. For example, if selectors s1, s2, and s3 have been declared, you could write: 's1 or s2 and not s3' which would select a particular residue if that residue were selected by s1 or if it were selected by s2 but not by s3.


Subtag **Segment**:   Describes the properties of a given segment of the nub motif

-   **order**: (REQUIRED) Specifies to which motif segment this definition is targetting
-   **n_term_flex**: Number of residues in the N-terminus of the motif segment allowed to move
-   **c_term_flex**: Number of residues in the C-terminus of the motif segment allowed to move
-   **editable**: Residues in the motif allowed to mutate (COLDSPOTS)

---
